import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as n}from"./app-aKKAEnwc.js";const l={};function p(t,s){return n(),e("div",null,s[0]||(s[0]=[a(`<h2 id="_1、什么是-monorepo" tabindex="-1"><a class="header-anchor" href="#_1、什么是-monorepo"><span>1、什么是 Monorepo ?</span></a></h2><p><code>Monorepo</code>是管理项目代码的方式之一，指在一个大的项目仓库（repo）中 管理多个模块/包（package），这种类型的项目大都在项目根目录下有一个packages文件夹，分多个项目管理。大概结构如下：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>├── packages</span></span>
<span class="line"><span>|   ├── pkg1</span></span>
<span class="line"><span>|   |   ├── package.json</span></span>
<span class="line"><span>|   ├── pkg2</span></span>
<span class="line"><span>|   |   ├── package.json</span></span>
<span class="line"><span>├── package.json</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目前很很多大型项目采用这样的结构，比如：<code>Babel</code>、<code>vue3</code>和<code>vite</code>等。</p><p>Monorepo 的好处在哪里嘞？</p><ul><li><strong>统一管理</strong>。比如微前端项目，多个子应用可以放在同一个<code>monorepo</code>中方便管理；后端用<code>node.js</code>的项目放在<code>monorepo</code>中也可以使用同一套技术栈管理。在CI/CD等流水线过程中，方便统一迭代或升级版本，也方便做通用化的配置，适用到多个子项目当中。</li><li><strong>依赖提升</strong>。如果多个项目都依赖了诸如<code>react</code>、<code>vue</code>或<code>TypeScript</code>等常用库，那可以通过<code>lerna</code>或者<code>yarn workspace</code>将依赖提升到最外层，多个子模块/包复用同一个依赖，减小项目体积。</li></ul><h2 id="_2、什么是-pnpm" tabindex="-1"><a class="header-anchor" href="#_2、什么是-pnpm"><span>2、什么是 pnpm</span></a></h2><p>官网：<a href="https://pnpm.nodejs.cn/" target="_blank" rel="noopener noreferrer">https://pnpm.nodejs.cn/</a></p><p>非常推荐先阅读这两篇文章了解 pnpm 的优势：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/404784010" target="_blank" rel="noopener noreferrer">zoomdong：Pnpm: 最先进的包管理工具</a></li><li><a href="https://zhuanlan.zhihu.com/p/422003598" target="_blank" rel="noopener noreferrer">熊猫MrPanda：【译】pnpm vs Yarn: monorepo node_modules</a></li></ul><p>在开始之前，可以带着下面几个问题阅读：</p><ol><li>什么是”幻影依赖“和”NPM 分身“？</li><li>什么是”硬链接“和”软链接“？</li><li>pnpm 是如何进行包的缓存？</li><li>monorepo的场景下，pnpm 如何将依赖提升？</li></ol><h2 id="_3、快速开始" tabindex="-1"><a class="header-anchor" href="#_3、快速开始"><span>3、快速开始</span></a></h2><p>先全局安装一个 pnpm，然后通过：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pnpm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> init</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>创建一个项目——在本例中，我们实现一个前后端分离、共同管理的 demo。</p><p>首先，我们需要理解 pnpm 中的工作区，在 pnpm 中可以通过创建并配置 pnpm-workspace.yaml 设置 workspace：</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">packages</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  - </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;packages/**&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这段配置的意思就是通过 glob 语法将<code>packages</code>下的所有文件夹都当做一个package，添加到 monorepo 中进行管理。</p><p>接下来，我们就按照配置，创建<code>packages</code>文件夹，并在其目录中创建三个子项目，分别是：web端、node端和工具类。</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>├── packages</span></span>
<span class="line"><span>│   ├── server</span></span>
<span class="line"><span>│   ├── tools</span></span>
<span class="line"><span>│   └── web</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-1、全局依赖" tabindex="-1"><a class="header-anchor" href="#_3-1、全局依赖"><span><strong>3.1、全局依赖</strong></span></a></h3><p>我们知道不管是一个 web 项目还是一个 node 项目，它都是基于同一种语言编写，所以我们可以只安装一次 TypeScript，供三个项目使用，这就体现出了 monorepo 的优势。</p><p>类似于<code>TypeScript</code>或<code>lodash</code>这样通用的依赖，我们通常可以把他们安装到根目录，即使用下面这条命令：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pnpm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> typescript</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -D</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -W</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的<code>-D</code>指令大家都很熟悉，就是把依赖作为<code>devDependencies</code>安装；而<code>-W</code>就是把依赖安装到根目录的<code>node_modules</code>当中，目录结构大致如下：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>├── node_modules</span></span>
<span class="line"><span>│   ├── @types</span></span>
<span class="line"><span>│   └── typescript -&gt; .pnpm/typescript@4.4.4/node_modules/typescript</span></span>
<span class="line"><span>├── package.json</span></span>
<span class="line"><span>├── packages</span></span>
<span class="line"><span>│   ├── server</span></span>
<span class="line"><span>│   ├── tools</span></span>
<span class="line"><span>│   └── web</span></span>
<span class="line"><span>├── pnpm-lock.yaml</span></span>
<span class="line"><span>└── pnpm-workspace.yaml</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然packages下的项目都没有安装 ts，但是倘若在项目中使用到，就会通过依赖递归查找的原则逐级往上寻找，自然会找到 monorepo 中根目录的依赖。</p><h3 id="_3-2、局部依赖" tabindex="-1"><a class="header-anchor" href="#_3-2、局部依赖"><span><strong>3.2、局部依赖</strong></span></a></h3><p>对于某些依赖，可能仅存在于某几个 package 中，我们就可以单独为他们安装，当然，可以通过<code>cd packges/xxx</code>后，执行<code>pnpm install xxx</code>，但这样重复操作多次未免有些麻烦，pnpm 提供了一个快捷指令——filter。</p><p>比如我们只在 web 应用中用到<code>vue</code>，那就可以为它单独安装。首先要拿到它的 package name，这个是我们在子项目中自定义的，通常是”@命名空间+包名@“的方式，比如<code>@vite/xx</code>或<code>@babel/xx</code>，在本例中，我们都以@panda开头。那么命令如下：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pnpm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> vue</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -r</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --filter</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> @panda/web</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在<code>packages/web/package.json</code>中，我们可以看到：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;dependencies&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    &quot;vue&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;^3.0.4&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时，该子项目的<code>node_modules</code>中也可以看到<code>vue</code>被添加了进来。</p><h3 id="_3-3、link-机制" tabindex="-1"><a class="header-anchor" href="#_3-3、link-机制"><span><strong>3.3、link 机制</strong></span></a></h3><p>在 monorepo 中，我们往往需要 package 间的引用，比如本例中的<code>@panda/tools</code>就会被<code>@panda/server</code>和<code>@panda/web</code>依赖。</p><p>我们可以使用类似于 3.2 中的方法安装：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pnpm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> i</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> @panda/tools</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -r</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --filter</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> @panda/server</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> @panda/web</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在执行前，我们可以添加一个函数，比如：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> const</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getNow</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Date</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>导出一个函数后，我们执行刚才的安装指令，这时在项目中会以<code>workspace</code>的版本体现。我们查看web项目中的 package.json：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;dependencies&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    &quot;@panda/tools&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;workspace:^1.0.0&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 通过 workspace 为本地引用</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    &quot;vue&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;^3.0.4&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  },</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过软链接引用了我们的tools package，我们就可以使用了正常的引入和调用了！</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">getNow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;@panda/tools&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getNow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用VSCode自带的快速跳转，我们可以直接跳转到tools源代码定义文件中，这样就巧妙地运用了 monorepo 的优势。</p><p>这时你会有一个疑问：当这样的工具包被发布到平台后，如何识别其中的<code>workspace</code>呢？</p><p>实际上，当执行了<code>pnpm publish</code>后，会把基于的workspace的依赖变成外部依赖，如：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// before  </span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;dependencies&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    &quot;@panda/tools&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;workspace:^1.0.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  },</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// after</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;dependencies&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    &quot;@panda/tools&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;^1.0.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  },</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决了开发环境和生产环境对依赖的问题。</p><h3 id="_3-4、启动与开发" tabindex="-1"><a class="header-anchor" href="#_3-4、启动与开发"><span><strong>3.4、启动与开发</strong></span></a></h3><p><code>-F</code>【--filter】： 使用哪个包</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;scripts&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    &quot;start&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;pnpm run  -F @panda/web  dev&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个 monorepo 往往是一个整体的项目，所以我们需要同时执行多个指令，在 pnpm 中，可以通过<code>-C</code>进行配置：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;scripts&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    &quot;start&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;pnpm -C ./packages/server start:server &amp; pnpm -C ./packages/web dev&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这条命令的含义就是同时运行服务端和前端代码。</p><p>而<code>start:server</code>和<code>dev</code>都是我们在子项目的<code>scripts</code>中自己配置的。</p><p>如果经过了 git 合码后，项目的依赖变化比较大，可以配置一条 clean 指令：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;scripts&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    &quot;clean&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;rm -rf node_modules **/*/node_modules&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样根目录和子应用下的<code>node_modules</code>都会被删除。再次执行<code>pnpm install</code>也会同时为根目录和所有 package 安装需要的依赖。</p><p>在实际开发中，我们往往会纠结什么样的代码应该放在业务项目中，什么样的代码要单独抽离为一个 package。举几个很简单的例子：</p><ul><li>对于一个大型的应用我们通常需要定制一套组件库，那么我们就可以把组件库最基础的部分抽离成 package，在业务代码中进行二次业务封装，这样在其他的项目也能复用。</li><li>如果一个项目包含 PC 和 H5，我们不妨把这两类项目拆分成不同的 package。</li><li>如果你在打造一个工具，而它具备了 parser、render等能力，那也可以将不同的能力解耦到不同的 package 当中。</li></ul>`,62)]))}const r=i(l,[["render",p],["__file","index.html.vue"]]),k=JSON.parse('{"path":"/webframe/monorepo/","title":"monorepo 项目工程","lang":"zh-CN","frontmatter":{"title":"monorepo 项目工程","author":"RJMeteor","createTime":"2024/12/02 04:41:42","permalink":"/webframe/monorepo/"},"headers":[{"level":2,"title":"1、什么是 Monorepo ?","slug":"_1、什么是-monorepo","link":"#_1、什么是-monorepo","children":[]},{"level":2,"title":"2、什么是 pnpm","slug":"_2、什么是-pnpm","link":"#_2、什么是-pnpm","children":[]},{"level":2,"title":"3、快速开始","slug":"_3、快速开始","link":"#_3、快速开始","children":[{"level":3,"title":"3.1、全局依赖","slug":"_3-1、全局依赖","link":"#_3-1、全局依赖","children":[]},{"level":3,"title":"3.2、局部依赖","slug":"_3-2、局部依赖","link":"#_3-2、局部依赖","children":[]},{"level":3,"title":"3.3、link 机制","slug":"_3-3、link-机制","link":"#_3-3、link-机制","children":[]},{"level":3,"title":"3.4、启动与开发","slug":"_3-4、启动与开发","link":"#_3-4、启动与开发","children":[]}]}],"git":{"createdTime":1733138330000,"updatedTime":1733138330000,"contributors":[{"name":"RJMeteor","email":"3029364473@qq.com","commits":1}]},"readingTime":{"minutes":5.57,"words":1671},"filePathRelative":"pages/webframe/engineer/monorepo.md","localizedDate":"2024年12月2日","excerpt":"<h2>1、什么是 Monorepo ?</h2>\\n<p><code>Monorepo</code>是管理项目代码的方式之一，指在一个大的项目仓库（repo）中 管理多个模块/包（package），这种类型的项目大都在项目根目录下有一个packages文件夹，分多个项目管理。大概结构如下：</p>\\n<div class=\\"language-text line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"text\\" data-title=\\"text\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>├── packages</span></span>\\n<span class=\\"line\\"><span>|   ├── pkg1</span></span>\\n<span class=\\"line\\"><span>|   |   ├── package.json</span></span>\\n<span class=\\"line\\"><span>|   ├── pkg2</span></span>\\n<span class=\\"line\\"><span>|   |   ├── package.json</span></span>\\n<span class=\\"line\\"><span>├── package.json</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');export{r as comp,k as data};
