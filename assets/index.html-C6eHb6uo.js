import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as l}from"./app-qz-5edv2.js";const s="/leaning_book/assets/btree-CBKc7z4c.gif",t="/leaning_book/assets/b_tree-BcU7OJk7.png",p="/leaning_book/assets/b_treesize-D5L1Xg63.png",o="/leaning_book/assets/fuindex-BSshObNe.png",d="/leaning_book/assets/indexDownTest-Dk5pbJuN.jpeg",r="/leaning_book/assets/indexDownNo-D8eXPUuP.jpeg",c="/leaning_book/assets/indexDownY-Dybs-7Pd.jpeg",h={};function g(b,i){return l(),a("div",null,i[0]||(i[0]=[n('<div class="hint-container tip"><p class="hint-container-title">提示</p><p>理解什么是回表，得先搞清楚Mysql存储数据结构</p><p>聚簇索引、非聚簇索引（普通索引/二级索引/辅助索引）</p><p>以及理解索引下推</p><p>为避免回表该怎么应对</p></div><h2 id="_1-存储引擎" tabindex="-1"><a class="header-anchor" href="#_1-存储引擎"><span>1. 存储引擎</span></a></h2><p>Mysql默认采用的是采用的是<code>Innodb存储引擎</code>，存储数据结构使用的<code>B+树</code></p><p>主流的Mysql存储引擎包括Innodb、Myisam</p><h3 id="_1-1-innodb" tabindex="-1"><a class="header-anchor" href="#_1-1-innodb"><span>1.1 Innodb</span></a></h3><ul><li>支持<code>ACID</code>（原子性、一致性、隔离性、持久性）事务，以及事务回滚</li><li>支持更细粒的锁（表锁、行锁、间隙锁、意向锁、排他锁、共享锁）</li><li>底层存储结构采用<code>B+树</code></li><li>支持外键约束</li><li>可以从灾难中恢复（通过bin-log日志等）</li><li>支持自动增加列属性<code>auto_increment</code></li><li>索引和数据是放在一个文件存储的</li></ul><h3 id="_1-2-myisam" tabindex="-1"><a class="header-anchor" href="#_1-2-myisam"><span>1.2 Myisam</span></a></h3><ul><li>不支持事务</li><li>只支持表锁</li><li>没有外键约束</li><li>不能在表损坏后恢复数据</li><li>索引和数据是分文件存储的</li></ul><h2 id="_2-b-树" tabindex="-1"><a class="header-anchor" href="#_2-b-树"><span>2. B+树</span></a></h2><h3 id="_2-1-b树" tabindex="-1"><a class="header-anchor" href="#_2-1-b树"><span>2.1 B树</span></a></h3><p>自平衡二叉树虽然能保持查询操作的时间复杂度在O(logn)，但是因为它本质上是一个二叉树，每个节点只能有 2 个子节点，那么当节点个数越多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。</p><p>为了解决降低树的高度的问题，后面就出来了 B 树，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。</p><p>B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树。</p><p>假设 M = 3，那么就是一棵 3 阶的 B 树，特点就是每个节点最多有 2 个（M-1个）数据和最多有 3 个（M个）子节点，超过这些要求的话，就会分裂节点，比如下面的的动图：</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是 3 ，所以在查询过程中会发生 3 次磁盘 I/O 操作。</p><p>而如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，B 树在数据查询中比平衡二叉树效率要高。</p><p>由于B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</p><h3 id="_2-2-b-树" tabindex="-1"><a class="header-anchor" href="#_2-2-b-树"><span>2.2 B+树</span></a></h3><blockquote><p>Mysql会先把非叶子节点先读进内存中，只有要读取数据的时候才正在进行IO操作</p><p>B+树的数据存储是根据RowId或索引的大小进行顺序存储的</p></blockquote><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但是 Innodb 使用的 B+ 树有一些特别的点，比如：</p><ul><li>B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。</li><li>B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。</li></ul><p>16KB是一个什么概念呢？如果用来装非叶子节点，一个Page（数据页）大概 可以装1000个Key（16K，假设Key是64位整数，8个字节，再加上各种 其他字段），意味着B+树有1000个分叉；如果用来装叶子节点，一个 Page大概可以装200条记录（记录和索引放在一起存储，假设一条记录大概100个字节）。基于这种估算，一个三层的B+树可以存储多少数据 量呢？如图下图所示：</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>第一层：一个节点是一个Page，里面存放了1000个Key，对应1000 个分叉。</li><li>第二层：1000个节点，1000个Page，每个Page里面装1000个Key。</li><li>第三层：1000×1000个节点（Page），每个Page里面装200条记录， 即是1000×1000×200 =2亿条记录，总容量是16KB×1000×1000，约16GB。</li></ul><p>把第一层和第二层的索引全装入内存里，即（1+1000）×16KB，也 即约16MB的内存。<strong>三层B+树就可以支撑2亿条记录</strong>，并且一次基于主 键的等值查询，只需要一次I/O（读取叶子节点）。由此可见B+树的强 大！</p><h3 id="_2-3-b-和-b-的区别" tabindex="-1"><a class="header-anchor" href="#_2-3-b-和-b-的区别"><span>2.3 B 和 B+的区别</span></a></h3><ul><li><p>在B树中，你可以将键和值存放在内部节点和叶子节点</p></li><li><p>在B+树中，内部节点都是键，没有值。叶子节点同时存放键和值</p></li><li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p></li></ul><h2 id="_3-聚簇索引、非聚簇索引" tabindex="-1"><a class="header-anchor" href="#_3-聚簇索引、非聚簇索引"><span>3. 聚簇索引、非聚簇索引</span></a></h2><p><strong>聚簇索引</strong>：将数据与主键一起存储，主键指向具体的数据【每个表都可以没有非聚簇索引，也可以有多个非聚簇索引】</p><p><strong>非聚簇索引</strong>：普通索引和主键一起存储，主键指向具体的数据【每个表都可以没有非聚簇索引，也可以有多个非聚簇索引】</p><p>聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一且非空的索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键（类似oracle中的RowId）作为聚簇索引。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p>InnoDB中，聚簇索引将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用&quot;where id = 14&quot;这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。</p></li><li><p>若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）</p></li></ol><h2 id="_4-什么是回表" tabindex="-1"><a class="header-anchor" href="#_4-什么是回表"><span>4. 什么是回表</span></a></h2><p>回表也就是先通过普通索引（我们自己建的索引不管是单列索引还是联合索引，都称为普通索引）在<code>非聚簇索引树</code>中拿到<code>主键ID</code> 再去<code>聚簇索引树</code>中才能取出具体要的数据。</p><p>所以回表的产生也是需要一定条件的，如果一次索引查询就能获得所有需要的select 记录就不需要回表，如果select 所需获得列中有其他的非索引列，就会发生回表动作。即基于非主键索引的查询需要多扫描一棵索引树。</p><div class="hint-container tip"><p class="hint-container-title">举个例子</p><p>表tbl有a,b,c三个字段，其中 a是主键，b上建了索引，然后编写sql语句<code>SELECT * FROM tbl WHERE a=1</code>这样不会产生回表，因为是根据<code>主键</code>去查找所有的数据在聚簇索引树中均能找到就不会回表。</p><p>如果是<code>SELECT * FROM tbl WHERE b=1</code>这样就会产生回表，因为where条件是b字段，那么会去b的<code>非聚簇索引树</code>里取出主键ID再去<code>聚簇索引树</code>中查找数据，这里就进行了两次IO操作。</p><p>如果是<code>SELECT b,a FROM tbl WHERE b=1</code>这样就不会回表，因为在<code>非聚簇索引树</code>中就能得到b列的值就不用回表了。</p></div><h3 id="_4-1-什么是覆盖索引" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是覆盖索引"><span>4.1 什么是覆盖索引？</span></a></h3><p>select 要查询的列是覆盖索引中的索引列</p><p>覆盖索引不会回表查询，查询效率也是比较高的</p><div class="hint-container tip"><p class="hint-container-title">举个例子</p><p>age,name -&gt; index</p><p>select age from user where age &gt;20 and name like&quot;张%&quot; ;</p></div><h2 id="_5-索引下推" tabindex="-1"><a class="header-anchor" href="#_5-索引下推"><span>5.索引下推</span></a></h2><blockquote><p><strong>EXPLAN分析</strong>当使用explan进行分析时，如果使用了索引条件下推，Extra会显示Using index condition。</p></blockquote><p>**注意：**索引下推是为了减少回表而发明的。</p><p>索引下推(Index Condition Pushdown，简称ICP)，从MySQL5.6开始引入的一个特性,索引下推通过减少回表的次数来提高数据库的查询效率;</p><p>索引下推的产生一定围绕着回表，没有回表那就没必要产生索引下推，因为上面也说了索引下推的目的就是减少回表，而不是避免回表。（题外话：避免回表使用索引覆盖——建立覆盖索引（联合索引））</p><p>所谓索引下推就是先根据联合索引或单列索引在<code>存储引擎层</code>实现条件判断然后回表，返回给Mysql服务层，有其他条件（非索引列）在Mysql服务层过滤掉其他数据。</p><ul><li><p>不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件。</p></li><li><p>使用索引条件下推优化时，如果存在某些被索引的列的作为判断条件时，MySQL服务器将这一部分判断条件一起传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。</p></li></ul><div class="hint-container tip"><p class="hint-container-title">说明</p><p>在没有使用ICP的情况下：</p><ul><li>获取下一行，首先读取索引信息，然后根据索引将整行数据读取出来。</li><li>然后通过where条件判断当前数据是否符合条件，符合返回数据。</li></ul><p>使用ICP的情况下：</p><ul><li>获取下一行的索引信息。</li><li>检查索引中存储的列信息是否符合索引条件，如果符合将整行数据读取出来，如果不符合跳过读取下一行。</li><li>用剩余的判断条件，判断此行数据是否符合要求，符合要求返回数据。</li></ul></div><p>举例：使用一张用户表tuser，表里创建联合索引（name, age）。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tuser </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> like</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;张%&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_5-1-没有使用icp" tabindex="-1"><a class="header-anchor" href="#_5-1-没有使用icp"><span>5.1 <strong>没有使用ICP</strong>：</span></a></h4><p>可以看到需要回表两次，把我们联合索引的另一个字段age浪费了。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_5-2-使用icp" tabindex="-1"><a class="header-anchor" href="#_5-2-使用icp"><span>5.2 <strong>使用ICP</strong></span></a></h4><p>可以看到只回表了一次。</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',60)]))}const u=e(h,[["render",g],["__file","index.html.vue"]]),B=JSON.parse('{"path":"/databases/mysqlhuibiao/","title":"什么是回表？","lang":"zh-CN","frontmatter":{"title":"什么是回表？","author":"RJMeteor","createTime":"2024/11/08 04:41:42","permalink":"/databases/mysqlhuibiao/"},"headers":[{"level":2,"title":"1. 存储引擎","slug":"_1-存储引擎","link":"#_1-存储引擎","children":[{"level":3,"title":"1.1 Innodb","slug":"_1-1-innodb","link":"#_1-1-innodb","children":[]},{"level":3,"title":"1.2 Myisam","slug":"_1-2-myisam","link":"#_1-2-myisam","children":[]}]},{"level":2,"title":"2. B+树","slug":"_2-b-树","link":"#_2-b-树","children":[{"level":3,"title":"2.1 B树","slug":"_2-1-b树","link":"#_2-1-b树","children":[]},{"level":3,"title":"2.2 B+树","slug":"_2-2-b-树","link":"#_2-2-b-树","children":[]},{"level":3,"title":"2.3 B 和 B+的区别","slug":"_2-3-b-和-b-的区别","link":"#_2-3-b-和-b-的区别","children":[]}]},{"level":2,"title":"3. 聚簇索引、非聚簇索引","slug":"_3-聚簇索引、非聚簇索引","link":"#_3-聚簇索引、非聚簇索引","children":[]},{"level":2,"title":"4. 什么是回表","slug":"_4-什么是回表","link":"#_4-什么是回表","children":[{"level":3,"title":"4.1 什么是覆盖索引？","slug":"_4-1-什么是覆盖索引","link":"#_4-1-什么是覆盖索引","children":[]}]},{"level":2,"title":"5.索引下推","slug":"_5-索引下推","link":"#_5-索引下推","children":[]}],"git":{"createdTime":1733849015000,"updatedTime":1733849015000,"contributors":[{"name":"RJMeteor","email":"3029364473@qq.com","commits":1}]},"readingTime":{"minutes":8.75,"words":2626},"filePathRelative":"pages/databases/MySQL/什么是回表？.md","localizedDate":"2024年12月10日","excerpt":"<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<p>理解什么是回表，得先搞清楚Mysql存储数据结构</p>\\n<p>聚簇索引、非聚簇索引（普通索引/二级索引/辅助索引）</p>\\n<p>以及理解索引下推</p>\\n<p>为避免回表该怎么应对</p>\\n</div>\\n<h2>1. 存储引擎</h2>\\n<p>Mysql默认采用的是采用的是<code>Innodb存储引擎</code>，存储数据结构使用的<code>B+树</code></p>\\n<p>主流的Mysql存储引擎包括Innodb、Myisam</p>"}');export{u as comp,B as data};
