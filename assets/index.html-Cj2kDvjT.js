import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,a,o as s}from"./app-Bq0YlV9C.js";const l={};function o(n,e){return s(),d("div",null,e[0]||(e[0]=[a(`<h2 id="_1-页面生命周期" tabindex="-1"><a class="header-anchor" href="#_1-页面生命周期"><span>1. 页面生命周期</span></a></h2><p>HTML 页面的生命周期包含三个重要事件：</p><ul><li><code>DOMContentLoaded</code> —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成。</li><li><code>load</code> —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li><li><code>beforeunload/unload</code> —— 当用户正在离开页面时。</li></ul><p>每个事件都是有用的：</p><ul><li><code>DOMContentLoaded</code> 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。</li><li><code>load</code> 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。</li><li><code>beforeunload</code> 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li><li><code>unload</code> 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li></ul><p><code>DOMContentLoaded</code> 事件发生在 <code>document</code> 对象上。我们必须使用 <code>addEventListener</code> 来捕获它。</p><p>当整个页面，包括样式、图片和其他资源被加载完成时，会触发 <code>window</code> 对象上的 <code>load</code> 事件。可以通过 <code>onload</code> 属性获取此事件。</p><p>当访问者离开页面时，<code>window</code> 对象上的 <code>unload</code> 事件就会被触发。</p><p>如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，<code>beforeunload</code> 处理程序将要求进行更多确认。</p><p><code>document.readyState</code> 属性可以为我们提供当前加载状态的信息。</p><p>它有 3 个可能值：</p><ul><li><code>loading</code> —— 文档正在被加载。</li><li><code>interactive</code> —— 文档被全部读取。</li><li><code>complete</code> —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。</li></ul><p><code>document.readyStat</code>e是文档的当前状态，可以在<code>readystatechange</code>事件中跟踪状态更改：</p><ul><li><code>loading</code> —— 文档正在被加载。</li><li><code>interactive</code> —— 文档已被解析完成，与 <code>DOMContentLoaded</code> 几乎同时发生，但是在 <code>DOMContentLoaded</code> 之前发生。</li><li><code>complete</code> —— 文档和资源均已加载完成，与 <code>window.onload</code> 几乎同时发生，但是在 <code>window.onload</code> 之前发生。</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 当前状态</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">readyState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 状态改变时打印它</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">addEventListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;readystatechange&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">readyState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>这会导致两个重要的问题：</p><ol><li>脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。</li><li>如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容</li></ol></div><h2 id="_2-defer" tabindex="-1"><a class="header-anchor" href="#_2-defer"><span>2. defer</span></a></h2><p><code>defer</code> 特性告诉浏览器不要等待脚本。相反，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行。</p><p>换句话说：</p><ul><li>具有 <code>defer</code> 特性的脚本不会阻塞页面。</li><li>具有 <code>defer</code> 特性的脚本总是要等到 DOM 解析完毕，但在 <code>DOMContentLoaded</code> 事件之前执行。</li></ul><p><strong>具有 <code>defer</code> 特性的脚本保持其相对顺序，就像常规脚本一样。</strong></p><h2 id="_3-async" tabindex="-1"><a class="header-anchor" href="#_3-async"><span>3. async</span></a></h2><p><code>async</code> 特性与 <code>defer</code> 有些类似。它也能够让脚本不阻塞页面。但是，在行为上二者有着重要的区别。</p><p><code>async</code> 特性意味着脚本是完全独立的：</p><ul><li>浏览器不会因 <code>async</code> 脚本而阻塞（与 <code>defer</code> 类似）。</li><li>其他脚本不会等待 <code>async</code> 脚本加载完成，同样，<code>async</code> 脚本也不会等待其他脚本。</li><li>DOMContentLoaded和异步脚本不会彼此等待： <ul><li><code>DOMContentLoaded</code> 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）</li><li><code>DOMContentLoaded</code> 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）</li></ul></li></ul><p>换句话说，<code>async</code> 脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。<code>async</code> 脚本就是一个会在加载完成时执行的完全独立的脚本。</p><p><strong><code>async</code> 特性仅适用于外部脚本</strong></p><p>就像 <code>defer</code> 一样，如果 <code>&lt;script&gt;</code> 标签没有 <code>src</code> 特性（attribute），那么 <code>async</code> 特性会被忽略。</p><blockquote><p>preload和prefetch不会阻塞页面的加载</p></blockquote><h2 id="_4-preload" tabindex="-1"><a class="header-anchor" href="#_4-preload"><span>4. preload</span></a></h2><p>所需的资源立即加载，不会立即运行，用到了资源中才会运行</p><h2 id="_5-prefetch" tabindex="-1"><a class="header-anchor" href="#_5-prefetch"><span>5. prefetch</span></a></h2><p>所需的资源不立即运行，浏览器空虚的时候去加载资源，不会立即运行，用到了资源中才会运行</p>`,33)]))}const p=i(l,[["render",o],["__file","index.html.vue"]]),r=JSON.parse('{"path":"/webframe/loads/","title":"加载资源","lang":"zh-CN","frontmatter":{"title":"加载资源","author":"RJMeteor","createTime":"2024/12/02 04:41:42","permalink":"/webframe/loads/"},"headers":[{"level":2,"title":"1. 页面生命周期","slug":"_1-页面生命周期","link":"#_1-页面生命周期","children":[]},{"level":2,"title":"2. defer","slug":"_2-defer","link":"#_2-defer","children":[]},{"level":2,"title":"3. async","slug":"_3-async","link":"#_3-async","children":[]},{"level":2,"title":"4. preload","slug":"_4-preload","link":"#_4-preload","children":[]},{"level":2,"title":"5. prefetch","slug":"_5-prefetch","link":"#_5-prefetch","children":[]}],"git":{"createdTime":1734627731000,"updatedTime":1734627731000,"contributors":[{"name":"RJMeteor","email":"3029364473@qq.com","commits":1}]},"readingTime":{"minutes":3.7,"words":1111},"filePathRelative":"pages/webframe/basics/javascript/preload和prefetch.md","localizedDate":"2024年12月19日","excerpt":"<h2>1. 页面生命周期</h2>\\n<p>HTML 页面的生命周期包含三个重要事件：</p>\\n<ul>\\n<li><code>DOMContentLoaded</code> —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成。</li>\\n<li><code>load</code> —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li>\\n<li><code>beforeunload/unload</code> —— 当用户正在离开页面时。</li>\\n</ul>\\n<p>每个事件都是有用的：</p>"}');export{p as comp,r as data};
