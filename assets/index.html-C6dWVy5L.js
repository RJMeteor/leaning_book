import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as o,o as c}from"./app-CI1YPOuY.js";const n={};function i(a,t){return c(),e("div",null,t[0]||(t[0]=[o('<h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h2><p>在linux操作系统中<code>shell</code>文件往往是以<code>#!/bin/bash</code>开始（也可以没有）的目的是指定<code>解析器</code>，表示该文件是一个可执行linux命令的<code>可执行</code>文件。</p><p>我们可以把shell文件看成由许多命令一起组成的文件。</p><h2 id="符号介绍" tabindex="-1"><a class="header-anchor" href="#符号介绍"><span>符号介绍</span></a></h2><table><thead><tr><th>符号</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>&#39;&#39;</code>、<code>&quot;&quot;</code></td><td><code>‘’</code>不运行包裹的命令，<code>&quot;&quot;</code>能运行。</td><td></td></tr><tr><td><code>#</code></td><td>注释符号，后面的内容不会被执行</td><td><code># This line is a comment.</code></td></tr><tr><td><code>~</code></td><td>表示当前用户的主目录</td><td><code>cd ~</code></td></tr><tr><td><code>;</code></td><td>指令分隔符</td><td><code>cd ~/backup; mkdir startup</code></td></tr><tr><td><code>;;</code></td><td><code>case</code> 语句中选项的结束</td><td><code>case &quot;$fop&quot; in help) ...;; esac</code></td></tr><tr><td><code>,</code></td><td>运算中的分隔</td><td><code>let &quot;t1 = ((a = 5 + 3, b = 7 - 1))&quot;</code></td></tr><tr><td><code>/</code></td><td>表示目录或进行除法运算</td><td><code>cd /etc/rc.d</code></td></tr><tr><td><code>\\</code></td><td>转义字符，取消特殊符号的作用</td><td><code>echo &quot;Backup dir, \\$bkdir = $bkdir&quot;</code></td></tr><tr><td>`</td><td>`</td><td>管道，流式传输，将一个指令的输出作为下一个指令的输入</td></tr><tr><td><code>!</code></td><td>反逻辑条件</td><td><code>if [ &quot;$?&quot; != 0 ]; then ... fi</code></td></tr><tr><td><code>:</code></td><td>什么事都不干且返回状态值0</td><td><code>: &gt; f.$$</code></td></tr><tr><td><code>?</code></td><td>通配符，匹配一个任意字符</td><td><code>ls a?a1</code></td></tr><tr><td><code>*</code></td><td>通配符，匹配任意字符（包括零个字符）</td><td><code>ls a*a</code></td></tr><tr><td><code>**</code></td><td>次方运算</td><td><code>let &quot;sus=2**3&quot;</code></td></tr><tr><td><code>$</code></td><td>变量替换</td><td><code>echo &quot;vrs = $vrs&quot;</code></td></tr><tr><td><code>{}</code></td><td>1.定义一组命令，不会产生子Shell <br>2.生成连续数字</td><td>1.<code>{ a=1; echo &quot;a=$a&quot;; }</code><br>2.<code>{1..5}</code>--&gt;<code>1 2 3 4 5</code></td></tr><tr><td><code>${}</code></td><td>变量替换，能支持跟复杂的变量替换（进行变量的其他操作，比如截取，取长度）</td><td><code>&quot;${PATH}&quot;</code>Path变量值、<code>${#Path}</code>Path长度</td></tr><tr><td><code>$n</code></td><td>n是数字，$0 代表该脚本名称，$1-$9 代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}</td><td><code>. renjia.sh re</code>--&gt; <code>${0}</code><a href="http://xn--renjia-ve8k937d.sh" target="_blank" rel="noopener noreferrer">就是renjia.sh</a>、<code>${1}</code>就是re</td></tr><tr><td><code>$*</code></td><td>代表所有参数，作为一个整体</td><td><code>echo &quot;$*&quot;</code></td></tr><tr><td><code>$@</code></td><td>代表所有参数，保持区分</td><td><code>echo &quot;$@&quot;</code></td></tr><tr><td><code>$#</code></td><td>表示参数的数量</td><td><code>echo &quot;$#&quot;</code></td></tr><tr><td><code>$?</code></td><td>上一个命令的返回状态</td><td><code>echo &quot;$?&quot;</code></td></tr><tr><td><code>()</code></td><td>1.指令组，执行后不会影响外部环境的变量，会产生子shell线程<br>2.<code>()</code>可以生成数组;</td><td>1.<code>(a=1; echo $a)</code><br>2.<code>(1 2 3)</code></td></tr><tr><td><code>$()</code></td><td>执行<code>()</code>中的命名，得到其&#39;标准输出&#39;，返回数组形式结果</td><td><code>tmp=$(ll)</code></td></tr><tr><td><code>(())</code></td><td>算数运算</td><td><code>(( a = 10 ))</code></td></tr><tr><td><code>[]</code></td><td>1.条件判断，不能使用逻辑运算符<br>2.通配符<code>-</code>扩展</td><td>1.<code>if [ &quot;$a&quot; -eq 1 ]; then ... fi</code> <br>2.<code>renjia[1-3].txt</code>--&gt;<code>renjia1.txt、renjia2.txt...</code></td></tr><tr><td><code>[[]]</code></td><td>更强大的条件判断（能使用逻辑运算符）</td><td><code>if [[ $a -gt 5 ]]</code></td></tr><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td><td><code>command1 &amp;&amp; command2</code></td></tr><tr><td><code>&amp;</code></td><td>背景符号，指令放入后台执行</td><td><code>tar cvfz data.tar.gz data &amp;</code></td></tr><tr><td><code>\\&lt;...\\&gt;</code></td><td>单字边界，正则表达式</td><td><code>grep &#39;\\&lt;the\\&gt;&#39; FileA</code></td></tr></tbody></table><h2 id="重定向" tabindex="-1"><a class="header-anchor" href="#重定向"><span>重定向</span></a></h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>command &gt; file</td><td>将输出重定向到 file</td></tr><tr><td>command &lt; file</td><td>将输入重定向到file</td></tr><tr><td>command &gt;&gt; file</td><td>将输出以追加的方式重定向到 file。</td></tr><tr><td>n &gt;file</td><td>将文件描述符为n的文件重定向到file。</td></tr><tr><td>n&gt;&gt; file</td><td>将文件描述符为n的文件以追加的方式重定向到file。</td></tr><tr><td>n&gt;&amp;m</td><td>将输出文件m和n合并，合并过后就是标准输出</td></tr><tr><td>n&lt;&amp;m</td><td>将输出文件m和n合并，合并过后就是标准输入</td></tr></tbody></table><h3 id="错误输出重定向" tabindex="-1"><a class="header-anchor" href="#错误输出重定向"><span>错误输出重定向</span></a></h3><blockquote><p>我们在简单地用&lt;或&gt;时，相当于使用 0&lt; 或 1&gt;</p></blockquote><p>默认bash有3个标准输入输出设备(<strong>文件描述符</strong>)：</p><table><thead><tr><th>0</th><th>标准输入</th></tr></thead><tbody><tr><td>1</td><td>标准输出</td></tr><tr><td>2</td><td>错误输出</td></tr></tbody></table><p>如果执行脚本的时候发生错误，会输出到2上。<br> 要想将错误的输出也输出在标准输出上，需要重定向。</p><h4 id="错误输出重定向的用途" tabindex="-1"><a class="header-anchor" href="#错误输出重定向的用途"><span>错误输出重定向的用途</span></a></h4><ol><li>‌<strong>保存重要信息</strong>‌：当屏幕输出的信息很重要，并且希望保存这些信息时，可以将错误输出重定向到文件。</li><li>‌<strong>避免干扰</strong>‌：后台执行的程序不希望干扰屏幕正常的输出结果时，可以将错误输出重定向到文件。</li><li>‌<strong>定时任务执行结果存储</strong>‌：系统的执行命令，例如定时任务的执行结果，可以存储到文件中以便后续分析。</li><li>‌<strong>错误日志与正常日志分开</strong>‌：错误日志与正常日志可以分别输出到不同的文件保存，便于区分和管理。</li></ol><p>举例：</p><ol><li><code>./test.sh &gt; a.log 2&gt;&amp;1</code><ul><li>无<code>2&gt;&amp;1</code>：<code>./test.sh &gt;a.log</code>运行没有发生错误就记录到<code>a.log</code>中，有错误就打印到控制台中。</li><li>有<code>2&gt;&amp;1</code>：表示执行<code>./test.sh</code>时不管有无错误都记录到<code>a.log</code>中。</li></ul></li></ol><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h2><ol><li>声名：</li></ol><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[function] </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">funcname</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(){</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">.....</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>调用：</li></ol><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">funcname</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 参数1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 参数2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="3"><li>获取参数：</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>$1等于参数1，$2等于参赛2，依次内推</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>local</code>：只能在函数中使用，表示创建局部变量，local命令将变量名的可见范围限制在函数内部。</p><ol start="4"><li>举例：</li></ol><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> renjia</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">    echo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">$1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">,</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">$2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">renjia</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> renjia</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> dd</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>renjia,dd</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',28)]))}const l=d(n,[["render",i],["__file","index.html.vue"]]),h=JSON.parse('{"path":"/linux/shellscript/","title":"Shell脚本","lang":"zh-CN","frontmatter":{"title":"Shell脚本","author":"RJMeteor","createTime":"2024/11/08 04:41:42","permalink":"/linux/shellscript/"},"headers":[{"level":2,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":2,"title":"符号介绍","slug":"符号介绍","link":"#符号介绍","children":[]},{"level":2,"title":"重定向","slug":"重定向","link":"#重定向","children":[{"level":3,"title":"错误输出重定向","slug":"错误输出重定向","link":"#错误输出重定向","children":[]}]},{"level":2,"title":"函数","slug":"函数","link":"#函数","children":[]}],"git":{"createdTime":1731089128000,"updatedTime":1734463832000,"contributors":[{"name":"RJMeteor","email":"3029364473@qq.com","commits":1}]},"readingTime":{"minutes":4.01,"words":1202},"filePathRelative":"pages/linux/Shell/Shell脚本.md","localizedDate":"2024年11月8日","excerpt":"<h2>基本概念</h2>\\n<p>在linux操作系统中<code>shell</code>文件往往是以<code>#!/bin/bash</code>开始（也可以没有）的目的是指定<code>解析器</code>，表示该文件是一个可执行linux命令的<code>可执行</code>文件。</p>\\n<p>我们可以把shell文件看成由许多命令一起组成的文件。</p>\\n<h2>符号介绍</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>符号</th>\\n<th>描述</th>\\n<th>示例</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>\'\'</code>、<code>\\"\\"</code></td>\\n<td><code>‘’</code>不运行包裹的命令，<code>\\"\\"</code>能运行。</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td><code>#</code></td>\\n<td>注释符号，后面的内容不会被执行</td>\\n<td><code># This line is a comment.</code></td>\\n</tr>\\n<tr>\\n<td><code>~</code></td>\\n<td>表示当前用户的主目录</td>\\n<td><code>cd ~</code></td>\\n</tr>\\n<tr>\\n<td><code>;</code></td>\\n<td>指令分隔符</td>\\n<td><code>cd ~/backup; mkdir startup</code></td>\\n</tr>\\n<tr>\\n<td><code>;;</code></td>\\n<td><code>case</code> 语句中选项的结束</td>\\n<td><code>case \\"$fop\\" in help) ...;; esac</code></td>\\n</tr>\\n<tr>\\n<td><code>,</code></td>\\n<td>运算中的分隔</td>\\n<td><code>let \\"t1 = ((a = 5 + 3, b = 7 - 1))\\"</code></td>\\n</tr>\\n<tr>\\n<td><code>/</code></td>\\n<td>表示目录或进行除法运算</td>\\n<td><code>cd /etc/rc.d</code></td>\\n</tr>\\n<tr>\\n<td><code>\\\\</code></td>\\n<td>转义字符，取消特殊符号的作用</td>\\n<td><code>echo \\"Backup dir, \\\\$bkdir = $bkdir\\"</code></td>\\n</tr>\\n<tr>\\n<td>`</td>\\n<td>`</td>\\n<td>管道，流式传输，将一个指令的输出作为下一个指令的输入</td>\\n</tr>\\n<tr>\\n<td><code>!</code></td>\\n<td>反逻辑条件</td>\\n<td><code>if [ \\"$?\\" != 0 ]; then ... fi</code></td>\\n</tr>\\n<tr>\\n<td><code>:</code></td>\\n<td>什么事都不干且返回状态值0</td>\\n<td><code>: &gt; f.$$</code></td>\\n</tr>\\n<tr>\\n<td><code>?</code></td>\\n<td>通配符，匹配一个任意字符</td>\\n<td><code>ls a?a1</code></td>\\n</tr>\\n<tr>\\n<td><code>*</code></td>\\n<td>通配符，匹配任意字符（包括零个字符）</td>\\n<td><code>ls a*a</code></td>\\n</tr>\\n<tr>\\n<td><code>**</code></td>\\n<td>次方运算</td>\\n<td><code>let \\"sus=2**3\\"</code></td>\\n</tr>\\n<tr>\\n<td><code>$</code></td>\\n<td>变量替换</td>\\n<td><code>echo \\"vrs = $vrs\\"</code></td>\\n</tr>\\n<tr>\\n<td><code>{}</code></td>\\n<td>1.定义一组命令，不会产生子Shell <br>2.生成连续数字</td>\\n<td>1.<code>{ a=1; echo \\"a=$a\\"; }</code><br>2.<code>{1..5}</code>--&gt;<code>1 2 3 4 5</code></td>\\n</tr>\\n<tr>\\n<td><code>${}</code></td>\\n<td>变量替换，能支持跟复杂的变量替换（进行变量的其他操作，比如截取，取长度）</td>\\n<td><code>\\"${PATH}\\"</code>Path变量值、<code>${#Path}</code>Path长度</td>\\n</tr>\\n<tr>\\n<td><code>$n</code></td>\\n<td>n是数字，$0 代表该脚本名称，$1-$9 代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}</td>\\n<td><code>. renjia.sh re</code>--&gt; <code>${0}</code><a href=\\"http://xn--renjia-ve8k937d.sh\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">就是renjia.sh</a>、<code>${1}</code>就是re</td>\\n</tr>\\n<tr>\\n<td><code>$*</code></td>\\n<td>代表所有参数，作为一个整体</td>\\n<td><code>echo \\"$*\\"</code></td>\\n</tr>\\n<tr>\\n<td><code>$@</code></td>\\n<td>代表所有参数，保持区分</td>\\n<td><code>echo \\"$@\\"</code></td>\\n</tr>\\n<tr>\\n<td><code>$#</code></td>\\n<td>表示参数的数量</td>\\n<td><code>echo \\"$#\\"</code></td>\\n</tr>\\n<tr>\\n<td><code>$?</code></td>\\n<td>上一个命令的返回状态</td>\\n<td><code>echo \\"$?\\"</code></td>\\n</tr>\\n<tr>\\n<td><code>()</code></td>\\n<td>1.指令组，执行后不会影响外部环境的变量，会产生子shell线程<br>2.<code>()</code>可以生成数组;</td>\\n<td>1.<code>(a=1; echo $a)</code><br>2.<code>(1 2 3)</code></td>\\n</tr>\\n<tr>\\n<td><code>$()</code></td>\\n<td>执行<code>()</code>中的命名，得到其\'标准输出\'，返回数组形式结果</td>\\n<td><code>tmp=$(ll)</code></td>\\n</tr>\\n<tr>\\n<td><code>(())</code></td>\\n<td>算数运算</td>\\n<td><code>(( a = 10 ))</code></td>\\n</tr>\\n<tr>\\n<td><code>[]</code></td>\\n<td>1.条件判断，不能使用逻辑运算符<br>2.通配符<code>-</code>扩展</td>\\n<td>1.<code>if [ \\"$a\\" -eq 1 ]; then ... fi</code> <br>2.<code>renjia[1-3].txt</code>--&gt;<code>renjia1.txt、renjia2.txt...</code></td>\\n</tr>\\n<tr>\\n<td><code>[[]]</code></td>\\n<td>更强大的条件判断（能使用逻辑运算符）</td>\\n<td><code>if [[ $a -gt 5 ]]</code></td>\\n</tr>\\n<tr>\\n<td><code>&amp;&amp;</code></td>\\n<td>逻辑与</td>\\n<td><code>command1 &amp;&amp; command2</code></td>\\n</tr>\\n<tr>\\n<td><code>&amp;</code></td>\\n<td>背景符号，指令放入后台执行</td>\\n<td><code>tar cvfz data.tar.gz data &amp;</code></td>\\n</tr>\\n<tr>\\n<td><code>\\\\&lt;...\\\\&gt;</code></td>\\n<td>单字边界，正则表达式</td>\\n<td><code>grep \'\\\\&lt;the\\\\&gt;\' FileA</code></td>\\n</tr>\\n</tbody>\\n</table>"}');export{l as comp,h as data};
