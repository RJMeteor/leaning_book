import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as e,o as a}from"./app-BDTijKja.js";const n="/leaning_book/assets/jvminstance1-Dv_ubcFQ.png",s="/leaning_book/assets/jvminstance2-Dh4G8x_-.png",o="/leaning_book/assets/jvminstance3-20FhBN8H.png",c="/leaning_book/assets/jvminstance4-DLgD9O57.png",r="/leaning_book/assets/jvminstance5-QR2tvq7j.png",g={};function d(p,i){return a(),t("div",null,i[0]||(i[0]=[e('<h2 id="对象的实例化过程" tabindex="-1"><a class="header-anchor" href="#对象的实例化过程"><span><strong>对象的实例化过程</strong></span></a></h2><ul><li><strong>对象的实例化过程是分成两部分：类的加载初始化，对象的初始化</strong></li><li>要创建类的对象实例需要先加载并初始化该类，main方法所在的类需要先加载和初始化</li><li>类初始化就是执行<code>&lt;clinit&gt;</code>方法，对象实例化是执行<code>&lt;init&gt;</code>方法</li><li>一个子类要初始化需要先初始化父类</li></ul><h2 id="类的加载过程" tabindex="-1"><a class="header-anchor" href="#类的加载过程"><span>类的加载过程</span></a></h2><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>类的加载机制:如果没有相应类的class，则加载class到方法区。对应着加载-&gt;验证-&gt;准备-&gt;解析--&gt;初始化阶段 <ul><li>加载：载入class对象，不一定是从class文件获取，可以是jar包，或者动态生成的class</li><li>验证：校验class字节流是否符合当前jvm规范</li><li>准备：为<strong>类变量</strong>分配内存并设置变量的初始值(<strong>默认值</strong>)。如果是final修饰的对象则是赋值声明值</li><li>解析：将常量池的符号引用替换为直接引用</li><li>初始化：执行类构造器<code>&lt;client&gt;</code>(<strong>注意不是对象构造器</strong>)，为<strong>类变量</strong>赋值，执行静态代码块。jvm会保证子类的<code>&lt;client&gt;</code>执行之前，父类的<code>&lt;client&gt;</code>先执行完毕</li></ul></li><li>其中验证、准备、解析3个部分称为 连接</li><li><code>&lt;clinit&gt;</code>方法由<strong>静态变量赋值代码和静态代码块</strong>组成；先执行类静态变量显示赋值代码，再到静态代码块代码</li></ul><h2 id="触发类加载的条件" tabindex="-1"><a class="header-anchor" href="#触发类加载的条件"><span>触发类加载的条件</span></a></h2><ul><li>第一次创建类的新对象时，<strong>会触发类的加载初始化和对象的初始化函数<code>&lt;init&gt;</code>执行，这个是实例初始化，其他6个都是类初始化</strong></li><li>JVM启动时会先加载初始化包含main方法的类</li><li>调用类的静态方法（如执行invokestatic指令）</li><li>对类或接口的静态字段执行读写操作（即执行getstatic、putstatic指令）；不过final修饰的静态字段的除外(已经赋值，String和基本类型，不包含包装类型)，它被初始化为一个编译时常量表达式 <ul><li><strong>注意</strong>：操作静态字段时，只有直接定义这个字段的类才会被初始化；如通过其子类来操作父类中定义的静态字段，只会触发父类<code>&lt;clinit&gt;</code>的初始化而不是子类的初始化</li></ul></li><li>调用JavaAPI中的反射方法时(比调用java.lang.Class中的方法(Class.forName)，或者java.lang.reflect包中其他类的方法)</li><li>当初始化一个类时，其父类没有初始化，则需先触发父类的初始化(接口例外)</li></ul><h2 id="对象的实例化过程-1" tabindex="-1"><a class="header-anchor" href="#对象的实例化过程-1"><span>对象的实例化过程</span></a></h2><ul><li><p>对象实例化过程</p><p>其实就是执行类构造函数 对应在字节码文件中的<code>&lt;init&gt;()</code>方法(称之为实例构造器)；<code>&lt;init&gt;()</code>方法由</p><p>非静态变量、非静态代码块以及对应的构造器组成</p><ul><li><code>&lt;init&gt;()</code>方法可以重载多个，类有几个构造器就有几个<code>&lt;init&gt;()</code>方法</li><li><code>&lt;init&gt;()</code>方法中的代码执行顺序为：父类变量初始化，父类代码块，父类构造器，子类变量初始化，子类代码块，子类构造器。</li></ul></li><li><p>静态变量，静态代码块，普通变量，普通代码块，构造器的执行顺序</p></li></ul><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>具有父类的子类的实例化顺序如下</li></ul><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="类加载器和双亲委派规则-如何打破双亲委派规则" tabindex="-1"><a class="header-anchor" href="#类加载器和双亲委派规则-如何打破双亲委派规则"><span>类加载器和双亲委派规则，如何打破双亲委派规则</span></a></h2><ul><li><p>类加载器</p><ul><li>通过一个类的全限定名来获取<strong>描述此类的二进制字节流</strong>，实现这个动作的代码模块称为类加载器</li><li>任意一个类都需要其加载器和类本身来确定类在JVM的唯一性；每个类加载器都有自己的类名称空间，同一个类class由不同的加载器加载，则被JVM判断为不同的类</li></ul><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>双亲委派模型</p><ul><li>启动类加载器有C++代码实现，是虚拟机的一部分。负责加载\\lib下的类库</li><li>其他的类加载器有java语言实现，独立于JVM，并且继承ClassLoader</li><li>extention ClassLoader负责加载\\lib\\ext目录下的类库</li><li>application ClassLoader 负责加载用户路径下(ClassPath)的代码</li><li>不同的类加载器加载同一个class文件会导致出现两个类。而java给出解决方法是下层的加载器加委托上级的加载器去加载类，如果父类无法加载(在自己负责的目录找不到对应的类)，而交还下层类加载器去加载。如下图</li></ul><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>打破双亲委派模型</p><ul><li>双亲委派模型并不是一个强制的约束模型，而是java设计者推荐给开发者的类加载实现方式</li><li>双亲委派模型很好的解决各个类加载基础类的同一问题(越基础的类由越上层的加载器加载)，但是基础类总是作为用户代码调用的API，但是如果它的具体实现是下层的代码，此时基础类需要调用下层的代码，则需要打破双亲委派模型</li><li>如JNDI服务，JNDI的代码有启动类去加载(rt.jar)，它需要调用由独立厂商部署在应用程序classpath下的JNDI的SPI(Service Provider Interface)代码。为了解决SPI代码加载问题，java引入了线程上下文类加载器去加载SPI代码。也就是父类加载器请求子类去完成类的加载动作</li><li>线程上下文类加载器，线程创建时会从父线程继承，如果全局范围没有设置过，则默认设置为application Class Loader</li></ul></li></ul><h2 id="沙箱安全机制" tabindex="-1"><a class="header-anchor" href="#沙箱安全机制"><span>沙箱安全机制</span></a></h2><p>通过双亲委派机制实现了沙箱安全机制，保证java的核心类库不被修改，避免植入恶意代码。</p>',16)]))}const m=l(g,[["render",d],["__file","index.html.vue"]]),f=JSON.parse('{"path":"/java/instance/","title":"对象的实例化","lang":"zh-CN","frontmatter":{"title":"对象的实例化","author":"RJMeteor","createTime":"2024/11/08 04:42:01","permalink":"/java/instance/"},"headers":[{"level":2,"title":"对象的实例化过程","slug":"对象的实例化过程","link":"#对象的实例化过程","children":[]},{"level":2,"title":"类的加载过程","slug":"类的加载过程","link":"#类的加载过程","children":[]},{"level":2,"title":"触发类加载的条件","slug":"触发类加载的条件","link":"#触发类加载的条件","children":[]},{"level":2,"title":"对象的实例化过程","slug":"对象的实例化过程-1","link":"#对象的实例化过程-1","children":[]},{"level":2,"title":"类加载器和双亲委派规则，如何打破双亲委派规则","slug":"类加载器和双亲委派规则-如何打破双亲委派规则","link":"#类加载器和双亲委派规则-如何打破双亲委派规则","children":[]},{"level":2,"title":"沙箱安全机制","slug":"沙箱安全机制","link":"#沙箱安全机制","children":[]}],"git":{"createdTime":1735665933000,"updatedTime":1735670593000,"contributors":[{"name":"RJMeteor","email":"108923040+RJMeteor@users.noreply.github.com","commits":1},{"name":"RJMeteor","email":"3029364473@qq.com","commits":1}]},"readingTime":{"minutes":4.96,"words":1488},"filePathRelative":"pages/developmentLanguage/java/basics/JVM/对象实例化.md","localizedDate":"2024年12月31日","excerpt":"<h2><strong>对象的实例化过程</strong></h2>\\n<ul>\\n<li><strong>对象的实例化过程是分成两部分：类的加载初始化，对象的初始化</strong></li>\\n<li>要创建类的对象实例需要先加载并初始化该类，main方法所在的类需要先加载和初始化</li>\\n<li>类初始化就是执行<code>&lt;clinit&gt;</code>方法，对象实例化是执行<code>&lt;init&gt;</code>方法</li>\\n<li>一个子类要初始化需要先初始化父类</li>\\n</ul>\\n<h2>类的加载过程</h2>\\n<figure><figcaption></figcaption></figure>"}');export{m as comp,f as data};
