import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a,o as p}from"./app-xdcQUDNE.js";const r="/assets/mysqlmvcc-DAvdG4_G.png",l="/assets/mysqlreadview-viFyiV2F.png",d="/assets/mysqlreadview1-BNnmm2MR.png",n={};function o(s,e){return p(),t("div",null,e[0]||(e[0]=[a('<h2 id="_1-什么是mvcc" tabindex="-1"><a class="header-anchor" href="#_1-什么是mvcc"><span>1. 什么是MVCC</span></a></h2><p>MVCC全称是Multi-Version Concurrency Control（多版本并发控制），是一种并发控制的方法，通过维护一个数据的多个版本，减少读写操作的冲突。</p><p>如果没有MVCC，想要实现同一条数据的并发读写，还要保证数据的安全性，就需要操作数据的时候加读锁和写锁，这样就降低了数据库的并发性能。</p><p>有了MVCC，就相当于把同一份数据生成了多个版本，在操作的开始各生成一个快照，读写操作互不影响。无需加锁，也实现数据的安全性和事务的隔离性。</p><p>事务的四大特性中隔离性就是基于MVCC实现的。</p><h2 id="_2-事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_2-事务的隔离级别"><span>2. 事务的隔离级别</span></a></h2><p>说隔离级别之前，先说一下并发事务产生的问题：</p><ul><li><p>脏读： 一个事务读到其他事务未提交的数据。</p></li><li><p>不可重复读： 相同的查询条件，多次查询到的结果不一致，即读到其他事务提交后的数据。</p></li><li><p>幻读： 相同的查询条件，多次查询到的结果不一致，即读到其他事务提交后的数据。</p></li></ul><div class="hint-container tip"><p class="hint-container-title">四大隔离级别</p><p>不可重复读与幻读的区别是： 不可重复读是读到了其他事务执行update、delete后的数据，而幻读是读到其他事务执行insert后的数据。</p><p><code>读已提交</code>：同一个事务中，多次执行查询会重新生成新的<code>readView</code></p><p><code>可重复读</code>：同一个事务中，多次执行查询不会生成新的<code>readView</code>，沿用第一次执行查询产生的<code>readView</code></p><ul><li><p>Read UnCommitted（读未提交）： 读到其他事务未提交的数据，会出现脏读、不可重复读、幻读。</p></li><li><p>Read Committed（读已提交）： 读到其他事务已提交的数据，解决了脏读，会出现不可重复读、幻读。</p></li><li><p>Repeatable Read（可重复读）： 相同的条件，多次读取到的结果一致。解决了脏读、不可重复读，会出现幻读。</p></li><li><p>Serializable（串行化）： 所有事务串行执行，解决了脏读、不可重复读、幻读。</p></li></ul></div><h2 id="_3-mvcc的实现原理" tabindex="-1"><a class="header-anchor" href="#_3-mvcc的实现原理"><span>3. MVCC的实现原理</span></a></h2><p>回顾事务的特性</p><ul><li><strong>原子性：通过undolog实现。</strong></li><li><strong>持久性：通过redolog实现。</strong></li><li><strong>隔离性：通过加锁（当前读）&amp;MVCC（快照读）实现。</strong></li><li>一致性：通过undolog、redolog、隔离性共同实现。</li></ul><p>MVCC解决了读已提交中的问题<strong>不可重复读</strong>。</p><p>MVCC只在Read Committed和Repeatable Read两个隔离级别下起作用，因为Read UnCommitted隔离级别下，读写都不加锁，Serializable隔离级别下，读写都加锁，也就不需要MVCC了。</p><h3 id="_3-1-当前读和快照读" tabindex="-1"><a class="header-anchor" href="#_3-1-当前读和快照读"><span>3.1 当前读和快照读</span></a></h3><ul><li><p>当前读： 读取数据的最新版本，并对数据进行加锁。</p><p>例如：insert、update、delete、select for update、 select lock in share mode。</p><p>就是读取当前数据的最新记录，会加锁，为了保证其他事务不能修改记录（如select lock in share mode(<strong>共享锁</strong>), select for update ; update, insert ,delete(<strong>排他锁</strong>)）</p><blockquote><p>当前读由<strong>行锁+间隙锁</strong>实现</p></blockquote></li><li><p>快照读： 读取数据的历史版本，不对数据加锁。</p><p>例如：select</p><p>不加锁的select操作就是快照读（隔离级别<strong>不能是串行化</strong>，如果是串行化快照读就变成了当前读）</p><blockquote><p>快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p></blockquote><p><strong>MVCC是基于Undo Log、隐藏字段、Read View（读视图）实现的。</strong></p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li></ul><h3 id="_3-2-什么是readview呢" tabindex="-1"><a class="header-anchor" href="#_3-2-什么是readview呢"><span>3.2 <strong>什么是readview呢？</strong></span></a></h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>不同的隔离级别生成read view的时机不同。</p><p>在读已提交中，每一次执行都会生成一个新的read view。</p><p>在可重复读中，只会在开始执行的时候生成read view，之后的所有操作都使用的是同一个read view。</p></div><p>当我们用select读取数据时，这一时刻的数据会有很多个版本（例如上图有四个版本），但我们并不知道读取哪个版本，这时就靠readview来对我们进行读取版本的限制，<strong>通过readview我们才知道自己能够读取哪个版本</strong>。</p><p>在一个readview快照中主要包括以下这些字段：</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对readview中的参数做一些解释</p><p>m_ids：活跃的事务就是指还没有commit的事务。</p><p>max_trx_id：例如m_ids中的事务id为（1，2，3），那么下一个应该分配的事务id就是4，max_trx_id就是4。</p><p>creator_trx_id：执行select读这个操作的事务的id。</p><p><strong>readview如何判断版本链中的哪个版本可用呢？（重点！）</strong></p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>trx_id表示要读取的事务id</p><p>（1）如果要读取的事务id等于进行读操作的事务id，说明是我读取我自己创建的记录，那么为什么不可以呢。</p><p>（2）如果要读取的事务id小于最小的活跃事务id，说明要读取的事务已经提交，那么可以读取。</p><p>（3）max_trx_id表示生成readview时，分配给下一个事务的id，如果要读取的事务id大于max_trx_id，说明该id已经不在该readview版本链中了，故无法访问。</p><p>（4）m_ids中存储的是活跃事务的id，如果要读取的事务id不在活跃列表，那么就可以读取，反之不行。</p>',32)]))}const g=i(n,[["render",o],["__file","index.html.vue"]]),C=JSON.parse('{"path":"/databases/mysqlmvcc/","title":"什么是MVCC？","lang":"zh-CN","frontmatter":{"title":"什么是MVCC？","author":"RJMeteor","createTime":"2024/11/08 04:41:42","permalink":"/databases/mysqlmvcc/"},"headers":[{"level":2,"title":"1. 什么是MVCC","slug":"_1-什么是mvcc","link":"#_1-什么是mvcc","children":[]},{"level":2,"title":"2. 事务的隔离级别","slug":"_2-事务的隔离级别","link":"#_2-事务的隔离级别","children":[]},{"level":2,"title":"3. MVCC的实现原理","slug":"_3-mvcc的实现原理","link":"#_3-mvcc的实现原理","children":[{"level":3,"title":"3.1 当前读和快照读","slug":"_3-1-当前读和快照读","link":"#_3-1-当前读和快照读","children":[]},{"level":3,"title":"3.2 什么是readview呢？","slug":"_3-2-什么是readview呢","link":"#_3-2-什么是readview呢","children":[]}]}],"git":{"createdTime":1733849015000,"updatedTime":1735665933000,"contributors":[{"name":"RJMeteor","email":"3029364473@qq.com","commits":2}]},"readingTime":{"minutes":4.51,"words":1354},"filePathRelative":"pages/databases/MySQL/什么是MVCC.md","localizedDate":"2024年12月10日","excerpt":"<h2>1. 什么是MVCC</h2>\\n<p>MVCC全称是Multi-Version Concurrency Control（多版本并发控制），是一种并发控制的方法，通过维护一个数据的多个版本，减少读写操作的冲突。</p>\\n<p>如果没有MVCC，想要实现同一条数据的并发读写，还要保证数据的安全性，就需要操作数据的时候加读锁和写锁，这样就降低了数据库的并发性能。</p>\\n<p>有了MVCC，就相当于把同一份数据生成了多个版本，在操作的开始各生成一个快照，读写操作互不影响。无需加锁，也实现数据的安全性和事务的隔离性。</p>\\n<p>事务的四大特性中隔离性就是基于MVCC实现的。</p>\\n<h2>2. 事务的隔离级别</h2>"}');export{g as comp,C as data};
