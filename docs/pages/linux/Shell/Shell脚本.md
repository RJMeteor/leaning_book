---
title: Shell脚本
author: RJMeteor
createTime: 2024/11/08 04:41:42
permalink: /linux/shellscript/
---

## 基本概念

在linux操作系统中`shell`文件往往是以`#!/bin/bash`开始（也可以没有）的目的是指定`解析器`，表示该文件是一个可执行linux命令的`可执行`文件。

我们可以把shell文件看成由许多命令一起组成的文件。

## 符号介绍

| 符号       | 描述                                                         | 示例                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `''`、`""` | `‘’`不运行包裹的命令，`""`能运行。                           |                                                              |
| `#`        | 注释符号，后面的内容不会被执行                               | `# This line is a comment.`                                  |
| `~`        | 表示当前用户的主目录                                         | `cd ~`                                                       |
| `;`        | 指令分隔符                                                   | `cd ~/backup; mkdir startup`                                 |
| `;;`       | `case` 语句中选项的结束                                      | `case "$fop" in help) ...;; esac`                            |
| `,`        | 运算中的分隔                                                 | `let "t1 = ((a = 5 + 3, b = 7 - 1))"`                        |
| `/`        | 表示目录或进行除法运算                                       | `cd /etc/rc.d`                                               |
| `\`        | 转义字符，取消特殊符号的作用                                 | `echo "Backup dir, \$bkdir = $bkdir"`                        |
| `|`        | 管道，流式传输，将一个指令的输出作为下一个指令的输入         | `find / | grep renjia`                                       |
| `!`        | 反逻辑条件                                                   | `if [ "$?" != 0 ]; then ... fi`                              |
| `:`        | 什么事都不干且返回状态值0                                    | `: > f.$$`                                                   |
| `?`        | 通配符，匹配一个任意字符                                     | `ls a?a1`                                                    |
| `*`        | 通配符，匹配任意字符（包括零个字符）                         | `ls a*a`                                                     |
| `**`       | 次方运算                                                     | `let "sus=2**3"`                                             |
| `$`        | 变量替换                                                     | `echo "vrs = $vrs"`                                          |
| `{}`       | 1.定义一组命令，不会产生子Shell <br/>2.生成连续数字          | 1.`{ a=1; echo "a=$a"; }`<br/>2.`{1..5}`-->`1 2 3 4 5`       |
| `${}`      | 变量替换，能支持跟复杂的变量替换（进行变量的其他操作，比如截取，取长度） | `"${PATH}"`Path变量值、`${#Path}`Path长度                    |
| `$n`       | n是数字，$0 代表该脚本名称，$1-$9 代表第一到第九个参数，十以上的参数需要用大括号包含，如${10} | `. renjia.sh re`--> `${0}`就是renjia.sh、`${1}`就是re        |
| `$*`       | 代表所有参数，作为一个整体                                   | `echo "$*"`                                                  |
| `$@`       | 代表所有参数，保持区分                                       | `echo "$@"`                                                  |
| `$#`       | 表示参数的数量                                               | `echo "$#"`                                                  |
| `$?`       | 上一个命令的返回状态                                         | `echo "$?"`                                                  |
| `()`       | 1.指令组，执行后不会影响外部环境的变量，会产生子shell线程<br/>2.`()`可以生成数组; | 1.`(a=1; echo $a)`<br/>2.`(1 2 3)`                           |
| `$()`      | 执行`()`中的命名，得到其'标准输出'，返回数组形式结果         | `tmp=$(ll)`                                                  |
| `(())`     | 算数运算                                                     | `(( a = 10 ))`                                               |
| `[]`       | 1.条件判断，不能使用逻辑运算符<br/>2.通配符`-`扩展           | 1.`if [ "$a" -eq 1 ]; then ... fi` <br/>2.`renjia[1-3].txt`-->`renjia1.txt、renjia2.txt...` |
| `[[]]`     | 更强大的条件判断（能使用逻辑运算符）                         | `if [[ $a -gt 5 ]]`                                          |
| `&&`       | 逻辑与                                                       | `command1 && command2`                                       |
| `&`        | 背景符号，指令放入后台执行                                   | `tar cvfz data.tar.gz data &`                                |
| `\<...\>`  | 单字边界，正则表达式                                         | `grep '\<the\>' FileA`                                       |

## 重定向

| 命令            | 说明                                            |
| --------------- | ----------------------------------------------- |
| command > file  | 将输出重定向到 file                             |
| command < file  | 将输入重定向到file                              |
| command >> file | 将输出以追加的方式重定向到 file。               |
| n >file         | 将文件描述符为n的文件重定向到file。             |
| n>> file        | 将文件描述符为n的文件以追加的方式重定向到file。 |
| n>&m            | 将输出文件m和n合并，合并过后就是标准输出        |
| n<&m            | 将输出文件m和n合并，合并过后就是标准输入        |

### 错误输出重定向

> 我们在简单地用<或>时，相当于使用 0< 或 1>

默认bash有3个标准输入输出设备(**文件描述符**)：

| 0    | 标准输入 |
| ---- | -------- |
| 1    | 标准输出 |
| 2    | 错误输出 |

如果执行脚本的时候发生错误，会输出到2上。
要想将错误的输出也输出在标准输出上，需要重定向。

#### 错误输出重定向的用途

1. ‌**保存重要信息**‌：当屏幕输出的信息很重要，并且希望保存这些信息时，可以将错误输出重定向到文件。
2. ‌**避免干扰**‌：后台执行的程序不希望干扰屏幕正常的输出结果时，可以将错误输出重定向到文件。
3. ‌**定时任务执行结果存储**‌：系统的执行命令，例如定时任务的执行结果，可以存储到文件中以便后续分析。
4. ‌**错误日志与正常日志分开**‌：错误日志与正常日志可以分别输出到不同的文件保存，便于区分和管理。

举例：

1. `./test.sh > a.log 2>&1`
   - 无`2>&1`：`./test.sh >a.log`运行没有发生错误就记录到`a.log`中，有错误就打印到控制台中。
   - 有`2>&1`：表示执行`./test.sh`时不管有无错误都记录到`a.log`中。

## 函数

1. 声名：

~~~shell
[function] funcname(){.....}
~~~

2. 调用：

~~~shell
funcname 参数1 参数2
~~~

3. 获取参数：

~~~txt
$1等于参数1，$2等于参赛2，依次内推
~~~

`local`：只能在函数中使用，表示创建局部变量，local命令将变量名的可见范围限制在函数内部。

4. 举例：

~~~shell
function renjia() {
    echo  "$1,$2";
}

renjia renjia dd
~~~

输出：

~~~
renjia,dd
~~~





